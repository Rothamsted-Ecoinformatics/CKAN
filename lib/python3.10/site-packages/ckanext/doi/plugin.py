#!/usr/bin/env python3
# encoding: utf-8
#
# This file is part of ckanext-doi
# Created by the Natural History Museum in London, UK

from datetime import datetime
from logging import getLogger

from ckan.plugins import SingletonPlugin, implements, interfaces, toolkit

from ckanext.doi import cli
from ckanext.doi.lib.api import DataciteClient
from ckanext.doi.lib.helpers import (
    get_site_title,
    get_site_url,
    package_get_year,
    doi_test_mode,
)
from ckanext.doi.lib.metadata import build_metadata_dict, build_xml_dict
from ckanext.doi.model.crud import DOIQuery

log = getLogger(__name__)


from ckan.model import Session  # Make sure to import the CKAN model session

class DOIPlugin(SingletonPlugin, toolkit.DefaultDatasetForm):
    """
    CKAN DOI Extension.
    """

    implements(interfaces.IConfigurer)
    implements(interfaces.IPackageController, inherit=True)
    implements(interfaces.ITemplateHelpers, inherit=True)
    implements(interfaces.IClick)

    ## IClick
    def get_commands(self):
        log.info("Executing DOIPlugin.get_commands()")
        return cli.get_commands()

    ## IConfigurer
    def update_config(self, config):
        """
        Adds templates.
        """
        log.info("Executing DOIPlugin.update_config()")
        toolkit.add_template_directory(config, 'theme/templates')

    ## IPackageController
    def after_dataset_create(self, context, pkg_dict):
        """
        A new dataset has been created, so we need to check if oldDoi is present.
        If oldDoi is provided, it will be used. Otherwise, a new DOI will be minted.
        """
        log.info(f"Executing DOIPlugin.after_dataset_create() for dataset ID: {pkg_dict['id']}")

        # Load the package_show version of the dict
        pkg_show_dict = toolkit.get_action('package_show')(
            context, {'id': pkg_dict['id']}
        )

        # Check if 'oldDoi' field is provided
        old_doi = pkg_show_dict.get('oldDoi')

        if old_doi:
            # If oldDoi is provided, use it as the DOI
            log.info(f"Old DOI found: {old_doi} for dataset ID: {pkg_dict['id']}")
            doi = DOIQuery.read_package(pkg_dict['id'], create_if_none=True)
            doi.identifier = old_doi
            doi.published = datetime.now()
            pkg_dict['doi_status'] = True
            Session.add(doi)
            Session.commit()
            toolkit.h.flash_success(f'Old DOI {old_doi} set for dataset.')
        else:
            # Proceed with regular DOI minting process
            log.info(f"No old DOI found for dataset ID: {pkg_dict['id']}. Proceeding to mint new DOI.")
            DOIQuery.read_package(pkg_dict['id'], create_if_none=True)

    ## IPackageController
    def after_dataset_update(self, context, pkg_dict):
        """
        Dataset has been created/updated.

        Check if oldDoi is provided; if it is, use the provided DOI.
        Otherwise, mint a new DOI if needed.
        """
        log.info(f"Executing DOIPlugin.after_dataset_update() for dataset ID: {pkg_dict['id']}")
        
        # Check if 'oldDoi' field is provided
        old_doi = pkg_dict.get('oldDoi')

        if old_doi:
            log.info(f"Old DOI {old_doi} provided for dataset ID: {pkg_dict['id']}. Using old DOI.")
            # Read or create DOI object and assign the old DOI
            doi = DOIQuery.read_package(pkg_dict['id'], create_if_none=True)
            doi.identifier = old_doi
            doi.published = datetime.now()
            pkg_dict['doi_status'] = True
            Session.add(doi)
            Session.commit()
            toolkit.h.flash_success(f'Old DOI {old_doi} saved for dataset {pkg_dict["id"]}')
        else:
            # Is this active and public? If so we need to make sure we have an active DOI
            if pkg_dict.get('state', 'active') == 'active': #and not pkg_dict.get('private', False):
                log.info(f"Dataset {pkg_dict['id']} is active and public. Proceeding with DOI checks.")
                package_id = pkg_dict['id']

                # remove user-defined update schemas first (if needed)
                context.pop('schema', None)

                # Load the package_show version of the dict
                pkg_show_dict = toolkit.get_action('package_show')(
                    context, {'id': package_id}
                )

                # Load or create the local DOI (package may not have a DOI if extension was loaded
                # after package creation)
                doi = DOIQuery.read_package(package_id, create_if_none=False)

                client = DataciteClient()

                if doi is None:
                    log.info(f"Creating a new DOI entry for dataset ID: {package_id}")
                    doi = DOIQuery.read_package(package_id, create_if_none=True)

                metadata_dict = build_metadata_dict(pkg_show_dict)
                xml_dict = build_xml_dict(metadata_dict)

                if doi.published is None:
                    log.info(f"Minting new DOI for dataset ID: {package_id}")
                    # metadata gets created before minting
                    client.set_metadata(doi.identifier, xml_dict)
                    client.mint_doi(doi.identifier, package_id)
                    toolkit.h.flash_success('DataCite DOI created')
                else:
                    # DOI exists, check for updates
                    log.info(f"Checking for updates on existing DOI: {doi.identifier} for dataset ID: {package_id}")
                    same = client.check_for_update(doi.identifier, xml_dict)
                    if not same:
                        log.info(f"Updating DOI metadata for dataset ID: {package_id}")
                        client.set_metadata(doi.identifier, xml_dict)
                        toolkit.h.flash_success('DataCite DOI metadata updated')

        return pkg_dict

    ## IPackageController
    def after_dataset_show(self, context, pkg_dict):
        """
        Add the DOI details to the pkg_dict so it can be displayed.
        """
        log.info(f"Executing DOIPlugin.after_dataset_show() for dataset ID: {pkg_dict['id']}")
        doi = DOIQuery.read_package(pkg_dict['id'])
        if doi:
            log.info(f"DOI {doi.identifier} found for dataset ID: {pkg_dict['id']}")
            pkg_dict['doi'] = doi.identifier
            pkg_dict['doi_status'] = True if doi.published else False
            pkg_dict['domain'] = get_site_url().replace('http://', '')
            pkg_dict['doi_date_published'] = (
                datetime.strftime(doi.published, '%Y-%m-%d') if doi.published else None
            )
            pkg_dict['doi_publisher'] = toolkit.config.get('ckanext.doi.publisher')

    def after_create(self, *args, **kwargs):
        """
        CKAN 2.9 compat version of after_dataset_create.
        """
        log.info("Executing DOIPlugin.after_create()")
        return self.after_dataset_create(*args, **kwargs)

    def after_update(self, *args, **kwargs):
        """
        CKAN 2.9 compat version of after_dataset_update.
        """
        log.info("Executing DOIPlugin.after_update()")
        return self.after_dataset_update(*args, **kwargs)

    def after_show(self, *args, **kwargs):
        """
        CKAN 2.9 compat version of after_dataset_show.
        """
        log.info("Executing DOIPlugin.after_show()")
        return self.after_dataset_show(*args, **kwargs)

    # ITemplateHelpers
    def get_helpers(self):
        log.info("Executing DOIPlugin.get_helpers()")
        return {
            'package_get_year': package_get_year,
            'now': datetime.now,
            'get_site_title': get_site_title,
            'doi_test_mode': doi_test_mode,
        }

